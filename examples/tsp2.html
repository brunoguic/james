---
layout: default
---

<div>
    <ol class="breadcrumb">
        <li><a href="/index.html">Home</a></li>
        <li><a href="/examples">Examples</a></li>
        <li class="active">Travelling salesman problem (2)</li>
    </ol>

    <h2 class="page-header">
        Example 4B: The travelling salesman problem (2)
    </h2>

    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Info
        </h4>
        The parallel tempering algorithm is applied to optimize the round trip. Don't know what parallel tempering is?
        Read <a href="/docs/#parallel-tempering">this</a>.
    </div>
    <p>
        This example reconsiders the travelling salesman problem
        from <a href="/examples/tsp/">example 4A</a>.
        TSP is actually a permutation problem: the goal is to find the best permutation
        of cities so that visiting them in this order yields the lowest possible total travel distance.
        Part of the implementation for TSP will likely be the same for various other permutation problems.
        In that respect, it may be useful to design generic components that can be reused for any permutation
        problem. TSP can then be implemented by plugging in the necessary data and objective.
    </p>
    <p>
        All reusable permutation problem components defined here have been made available in the
        <a href="/getstarted/#modules">JAMES extensions module</a>.
    </p>

    <h4 class="page-header">
        A solution type for permutation problems
    </h4>
    <p>
        A permutation problem consists of finding an optimal order of a list of items.
        Thus, a solution indicates a specific order of these items.
        We will assume that every item is identified with a unique integer ID.
        This assumption is imposed later when defining a generic permutation
        problem, by restricting the allowed data type (see below).
        A <code>PermutationSolution</code> reflects an ordered list of these IDs.
        Its implementation is very similar to that of the <code>TSPSolution</code> from
        <a href="/examples/tsp/#solution-type">example 4A</a>.
    </p>
<pre class="prettyprint">
public class PermutationSolution extends Solution {

    // ordered sequence of IDs
    private List&lt;Integer&gt; order;

    public PermutationSolution(List&lt;Integer&gt; order) {
        this.order = order;
    }

    public List&lt;Integer&gt; getOrder(){
        return order;
    }

    public int size(){
        return order.size();
    }

    public void swap(int i, int j){
        int tmp = order.get(i);
        order.set(i, order.get(j));
        order.set(j, tmp);
    }

    @Override
    public PermutationSolution copy() {
        return new PermutationSolution(new ArrayList&lt;&gt;(order));
    }

    @Override
    public boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        if (getClass() != other.getClass()) {
            return false;
        }
        final PermutationSolution otherPerm = (PermutationSolution) other;
        return Objects.equals(this.order, otherPerm.order);
    }

    @Override
    public int hashCode() {
        Objects.hashCode(order);
    }

}
</pre>

    <h4 class="page-header">
        A generic permutation problem
    </h4>
    <p>
        Now we can define a generic, reusable permutation problem. It extends
        <code>GenericProblem</code>, fixing the solution type to <code>PermutationSolution</code>
        and the data type to any implementation of the <code>IntegerIdentifiedData</code>
        interface (also used for subset problems). The latter imposes that every item in
        the data set is assigned a unique integer ID, as assumed by the solution
        representation (see before).
    </p>
    <p>
        A default random solution generator is set when creating a permutation problem.
        Its implementation is very similar to that of the random solution generator
        from <a href="/examples/tsp/#random-solution-generation">example 4A</a>. The IDs
        of the items in the data set are retrieved from the data object. Since the
        <code>RandomSolutionGenerator</code> interface has a single method
        <code>create(rnd, data)</code> it can be compactly specified as a
        Java 8 lambda expression, as shown here.
    </p>
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Info
        </h4>
        The method <code>create(rnd, data)</code> of <code>RandomSolutionGenerator</code> takes a random generator as
        its first argument, which should be used as the source of randomness. Each search has a dedicated random generator,
        which is passed to the problem when requesting a random solutionn. If desired, a search's random generator can be
        customized with <code>search.setRandom(rnd)</code>.
    </div>
<pre class="prettyprint">
public class PermutationProblem&lt;DataType extends IntegerIdentifiedData&gt; extends GenericProblem&lt;PermutationSolution, DataType&gt;{

    public PermutationProblem(DataType data, Objective&lt;? super PermutationSolution, ? super DataType&gt; objective) {
        // pass data and objective to super class; specify random solution generator
        super(data, objective, (r,d) -> {
            // create list with all IDs
            List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(d.getIDs());
            // shuffle IDs
            Collections.shuffle(ids, r);
            // create and return permutation solution
            return new PermutationSolution(ids);
        });
    }

}
</pre>

    <h4 class="page-header">
        Permutation neighbourhood and corresponding move
    </h4>
    <p>
        To be able to apply neighbourhood searches to solve permutation problems, we need to provide at least one neighbourhood
        for the newly defined <code>PermutationSolution</code>.
        Here we create a <code>ReverseSubsequenceNeighbourhood</code> and corresponding move, similar to the <code>TSP2OptNeighbourhood</code>
        and move introduced in <a href="/examples/tsp/#neigh">example 4A</a>.
    </p>
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Info
        </h4>
        The extensions module contains several permutation neighbourhoods among which this <code>ReverseSubsequenceNeighbourhood</code>.
        Of course, custom neighbourhoods can also be defined when needed for specific permutation problems.
    </div>
<pre class="prettyprint">
public class ReverseSubsequenceMove implements Move&lt;PermutationSolution&gt;{

    // first and last position of subsequence that will be reversed
    private int from, to;

    public ReverseSubsequenceMove(int from, int to) {
        this.from = from;
        this.to = to;
    }

    public int getFrom(){
        return from;
    }

    public int getTo(){
        return to;
    }

    @Override
    public void apply(PermutationSolution solution) {
        int start = from;
        int stop = to;
        int n = solution.size();
        // reverse subsequence by performing a series of swaps
        // (works cyclically when start > stop)
        int reversedLength;
        if(start &lt; stop){
            reversedLength = stop-start+1;
        } else {
            reversedLength = n - (start-stop-1);
        }
        int numSwaps = reversedLength/2;
        for(int k=0; k&lt;numSwaps; k++){
            solution.swap(start, stop);
            start = (start+1) % n;
            stop = (stop-1+n) % n;
        }
    }

    @Override
    public void undo(PermutationSolution solution) {
        // undo by reversing again
        apply(solution);
    }

}
</pre>
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Info
        </h4>
        The method <code>getRandomMove(solution, rnd)</code> takes a random generator as its second argument, which should
        be used as the source of randomness. Each search has a dedicated random generator, which is passed to the neighbourhood
        when requesting a random move. If desired, a search's random generator can be customized with
        <code>search.setRandom(rnd)</code>.
    </div>
<pre class="prettyprint">
public class ReverseSubsequenceNeighbourhood implements Neighbourhood&lt;PermutationSolution&gt;{

    public ReverseSubsequenceMove getRandomMove(PermutationSolution solution, Random rnd) {
        int n = solution.size();
        // check: move possible
        if(n &lt; 2){
            return null;
        }
        // pick two random, distinct positions
        int i = rnd.nextInt(n);
        int j = rnd.nextInt(n-1);
        if(j >= i){
            j++;
        }
        // generate move
        return new ReverseSubsequenceMove(i, j);
    }

    @Override
    public List&lt;ReverseSubsequenceMove&gt; getAllMoves(PermutationSolution solution) {
        // initialize list
        List&lt;ReverseSubsequenceMove&gt; moves = new ArrayList&lt;&gt;();
        int n = solution.size();
        for(int i=0; i&lt;n; i++){
            for(int j=0; j&lt;n; j++){
                if(i != j){
                    moves.add(new ReverseSubsequenceMove(i, j));
                }
            }
        }
        return moves;
    }

}
</pre>
    <h4 class="page-header">
        TSP Data and objective
    </h4>
    <p>
        The generic permutation problem components can now be used to implement and solve TSP.
        We simply define the data and objective and wrap these in a
        <code>PermutationProblem</code>. As in <a href="/examples/tsp/#data">example 4A</a>,
        the data contains the distance matrix. It now implements the <code>IntegerIdentifiedData</code>
        interface, as required by the permutation problem definition. The IDs assigned to each city
        correspond to the row and column indices in the distance matrix and are automatically inferred.
    </p>
<pre class="prettyprint">
public class TSPData implements IntegerIdentifiedData {

    // travel distance matrix
    private final double[][] dist;

    // set of IDs
    private final Set&lt;Integer&gt; ids;

    public TSPData(double[][] dist) {
        // infer IDs
        ids = new HashSet&lt;&gt;();
        for(int i=0; i&lt;dist.length; i++){
            ids.add(i);
        }
        // store distance matrix
        this.dist = dist;
    }

    @Override
    public Set&lt;Integer&gt; getIDs() {
        return ids;
    }

    // get travel distance from the given city to the given other city
    public double getDistance(int from, int to){
        return dist[from][to];
    }

}
</pre>
    <p>
        The objective evaluates a permutation solution by computing the total travel
        distance of the round trip that visits cities in the order in which they occur
        in the permutation. The implementation is almost identical to that of the objective
        from <a href="/examples/tsp/#objective">example 4A</a>.
        It also includes an efficient delta evaluation for the applied move type.
        The solution type is set to <code>PermutationSolution</code> and the data
        type to <code>TSPData</code>.
    </p>
<pre class="prettyprint">
public class TSPObjective implements Objective&lt;PermutationSolution, TSPData&gt;{

    public Evaluation evaluate(PermutationSolution solution, TSPData data) {
        // compute sum of travel distances
        List&lt;Integer&gt; cities = solution.getOrder();
        int n = cities.size();
        double totalDistance = 0.0;
        for(int i=0; i&lt;n; i++){
            int fromCity = cities.get(i);
            int toCity = cities.get((i+1)%n);
            totalDistance += data.getDistance(fromCity, toCity);
        }
        // wrap in simple evaluation
        return SimpleEvaluation.WITH_VALUE(totalDistance);
    }

    public Evaluation evaluate(Move move, PermutationSolution curSolution, Evaluation curEvaluation, TSPData data){

        // check move type
        if(!(move instanceof ReverseSubsequenceMove)){
            throw new IncompatibleDeltaEvaluationException("Delta evaluation in "
                   + "TSP objective expects move of type ReverseSubsequenceMove.");
        }
        // cast move
        ReverseSubsequenceMove move2opt = (ReverseSubsequenceMove) move;
        // get bounds of reversed subsequence
        int from = move2opt.getFrom();
        int to = move2opt.getTo();
        // get number of cities
        int n = curSolution.size();

        if((to+1)%n == from){
            // special case: entire round trip reversed
            return curEvaluation;
        } else {
            // get current total travel distance
            double totalDistance = curEvaluation.getValue();
            // get current order of cities
            List&lt;Integer&gt; cities = curSolution.getOrder();

            // get crucial cities (at boundary of reversed subsequence)
            int beforeReversed = cities.get((from-1+n)%n);
            int firstReversed = cities.get(from);
            int lastReversed = cities.get(to);
            int afterReversed = cities.get((to+1)%n);

            // account for dropped distances
            totalDistance -= data.getDistance(beforeReversed, firstReversed);
            totalDistance -= data.getDistance(lastReversed, afterReversed);

            // account for new distances
            totalDistance += data.getDistance(beforeReversed, lastReversed);
            totalDistance += data.getDistance(firstReversed, afterReversed);

            // return updated travel distance
            return SimpleEvaluation.WITH_VALUE(totalDistance);
        }

    }

    public boolean isMinimizing() {
        return true;
    }

}
</pre>
    <h4 class="page-header">
        Optimizing the round trip
    </h4>
    <p>
        We can apply a parallel tempering algorithm in the same way as in
        <a href="/examples/tsp/#optimization">example 4A</a>.
        The problem is now a <code>PermutationProblem</code> that contains the TSP data and objective.
        The generic <code>ReverseSubsequenceNeighbourhood</code> is used, which corresponds to a 2-opt neighbourhood
        in the context of TSP.
    </p>
<pre class="prettyprint">
// create distance matrix (e.g. read from a file)
double[][] dist = ...
// create data
TSPData data = new TSPData(dist);
// create objective
TSPObjective obj = new TSPObjective();

// wrap data and objective in a permutation problem
PermutationProblem&lt;TSPData&gt; problem = new PermutationProblem&lt;&gt;(data, obj);

// set temperature range, scaled according to average
// distance between cities and their nearest neighbours
double scale = computeAvgNearestNeighbourDistance(data);
double minTemp = scale * 1e-8;
double maxTemp = scale * 0.6;
// create parallel tempering search with neighbourhood that reverses a subsequence (2-opt move)
int numReplicas = 10;
ParallelTempering&lt;PermutationSolution&gt; parallelTempering = new ParallelTempering&lt;&gt;(
                                                            problem,
                                                            new ReverseSubsequenceNeighbourhood(),
                                                            numReplicas, minTemp, maxTemp
                                                           );

// set maximum runtime
long timeLimit = ...
parallelTempering.addStopCriterion(new MaxRuntime(timeLimit, TimeUnit.SECONDS));
// attach listener (see example 1A)
parallelTempering.addSearchListener(new ProgressSearchListener());

// start search
parallelTempering.start();

// print results
if(parallelTempering.getBestSolution() != null){
    System.out.println("Best round trip: " + parallelTempering.getBestSolution().getOrder());
    System.out.println("Best round trip travel distance: " + parallelTempering.getBestSolutionEvaluation());
} else {
    System.out.println("No valid solution found...");
}

// dispose
parallelTempering.dispose();
</pre>
    <p>
        The average travel distance between each city and its closest neighbour is easily computed,
        which is used as scale factor for the temperatures (see <a href="/examples/tsp/#optimization">example 4A</a> to understand why).
    </p>
<pre class="prettyprint">
double computeAvgNearestNeighbourDistance(TSPData data){
    Set&lt;Integer&gt; ids = data.getIDs();
    double sum = 0.0;
    for(int id1 : ids){
        double min = Double.MAX_VALUE;
        for(int id2 : ids) {
            double dist = data.getDistance(id1, id2);
            if(dist > 0.0 &amp;&amp; dist &lt; min){
                min = dist;
            }
        }
        sum += min;
    }
    int n = ids.size();
    return sum/n;
}
</pre>
    <h4 class="page-header">
        Other permutation problems
    </h4>
    <p>
        The advantage of this approach over that from
        <a href="/examples/tsp/">example 4A</a> is that, with very little additional effort,
        other permutation problems can now also be defined and solved using the provided
        solution type, problem class and neighbourhood(s). These reusable components
        have been added to the <a href="/getstarted/#modules">JAMES extensions module</a>.
        Source code is found on <a href="https://github.com/hdbeukel/james-extensions/tree/v{{site.extensions-latest-stable}}/src/main/java/org/jamesframework/ext/permutation">GitHub</a>.
    </p>

    <h4 class="page-header">
        Full source code
    </h4>
    <p>
        The complete source code of this example is available on
        <a href="https://github.com/hdbeukel/james-examples/tree/v{{site.examples-latest-stable}}/src/main/java/org/jamesframework/examples/tsp2">GitHub</a>,
        including some additional code to read the input from a text file.
        You can also download a <a href="/getstarted/#releases-examples">ZIP file</a> that contains the Java sources of all examples, a compiled
        JAR (including all dependencies) as well as some input files for in case you want to run any of the examples. To run this example, execute
    </p>
<pre class="prettyprint">
$ java -cp james-examples.jar org.jamesframework.examples.tsp2.TSP2 &lt;inputfile&gt; &lt;runtime&gt;
</pre>
    </p>
        from the command line.
        The first line of the input file contains a single integer value (possibly surrounded by whitespace)
        that indicates the number of cities N. The remainder of the file contains the entries of the
        lower triangular part of an N &times; N symmetric distance matrix (row-wise without diagonal entries),
        separated by whitespace and/or newlines.
        The runtime is given in seconds.
    </p>
    <p>
        <ul class="list-unstyled">
            <li>
                <a href="/files/examples/TSP1.txt"><i class="fa fa-file-text-o"></i> Example input file (17 cities)</a>
            </li>
            <li>
                <a href="/files/examples/TSP2.txt"><i class="fa fa-file-text-o"></i> Example input file (48 cities)</a>
            </li>
            <li>
                <a href="/files/examples/TSP3.txt"><i class="fa fa-file-text-o"></i> Example input file (120 cities)</a>
            </li>
            <li>
                <a href="/files/examples/TSP4.txt"><i class="fa fa-file-text-o"></i> Example input file (561 cities)</a>
            </li>
        </ul>
    </p>
    <p>
        The example input files correspond to instances gr17, gr48, gr120 and pa561, respectively, from the
        <a href="http://www.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/" target="_blank">TSPLIB benchmark set</a>.
    </p>

</div>
