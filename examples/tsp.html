---
layout: default
---

<div>
    <ol class="breadcrumb">
        <li><a href="/index.html">Home</a></li>
        <li><a href="/examples">Examples</a></li>
        <li class="active">Travelling salesman problem</li>
    </ol>

    <h2 class="page-header">
        Example 4A: The travelling salesman problem
    </h2>

    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Info
        </h4>
        The random descent and parallel tempering algorithms are applied to optimize the round trip. Don't know what random descent is?
        Read <a href="/docs/#random-descent">this</a>. Never heard about parallel tempering? Read <a href="/docs/#parallel-tempering">this</a>.
    </div>
    <p>
        This example demonstrates how to implement and solve a basic symmetric travelling salesman problem (TSP).
        The problem consists of finding the shortest round trip that visits a number of given cities, each exactly once,
        returning to the city where the tour started. For symmetric TSP, it is assumed that the travel distance
        from city <var>a</var> to <var>b</var> is equal to that from <var>b</var> to <var>a</var>. The input consists
        of a (symmetric) distance matrix containing the travel distance between each pair of cities. The goal is to
        find the optimal order in which to visit the cities so that the total travel distance is minimzed.
    </p>

    <h4 class="page-header" id="solution-type">
        Designing a solution type
    </h4>
    <p>
        When defining a custom problem, the first step is to design the corresponding solution type. Here we create a <code>TSPSolution</code>
        class that models a solution to the TSP problem as a list of cities, in the order in which they are visited. Each of the N cities is represented
        by a unique number in [0, N-1]. In JAMES, it is required that all solution types extend the abstract <code>Solution</code> class, which has
        three required abstract methods to implement:
        <ol>
            <li>
                <code>Solution copy()</code>: creates a deep copy of the solution. It is important that the returned copy is of exactly the
                same type as the original solution. As it is allowed to confine the return type to a subtype when overriding a method, we may
                set it to <code>TSPSolution</code> here. In this example, the list of cities is copied and
                wrapped in a new <code>TSPSolution</code>.
            </li>
            <li>
                <code>boolean equals(Object)</code>: the default reference-based implementation from <code>Object</code> has been erased
                so that it is required to provide an appropriate equality check for every defined solution type. It is important that solutions
                are compared based on their contents (value-based) to guarantee correct behaviour of all optimization
                algorithms. In this example, the list of cities is compared (given that the other object is also a <code>TSPSolution</code>).
            </li>
            <li>
                <code>int hashCode()</code>: as always, it is required to provide a hash code computation in line with the
                custom equality definition. Here, a hash code is inferred from the list of cities.
            </li>
        </ol>
        A method <code>swapCities(i, j)</code> is also provided, to swap the two cities at the given positions. This will be used later to modify
        solutions during optimization.
    </p>
<pre class="prettyprint">
public class TSPSolution extends Solution {

    // list of cities in the order in which they are visited
    private List&lt;Integer&gt; cities;

    public TSPSolution(List&lt;Integer&gt; cities){
        this.cities = cities;
    }

    public List&lt;Integer&gt; getCities(){
        return cities;
    }

    // swap the i-th and j-th city in the round trip
    public void swapCities(int i, int j){
        Collections.swap(cities, i, j)
    }

    @Override
    public TSPSolution copy() {
        return new TSPSolution(new ArrayList&lt;&gt;(cities));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final TSPSolution other = (TSPSolution) obj;
        return Objects.equals(this.cities, other.cities);
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(cities);
    }

}
</pre>

    <h4 class="page-header" id="problem">
        Problem specification
    </h4>
    <p>
        We can now define the problem. The framework includes a <code>Problem</code> interface, which is parameterized on the solution type,
        in this case our newly introduced <code>TSPSolution</code>. The problem is responsible for evaluating and validating solutions,
        as well as generating random solutions, which are for example used as the default initial solutions of applied local searches. To facilitate
        problem specification, a predefined <code>GenericProblem</code> is provided, which is composed of data, an objective (for evaluation), possibly
        some constraints (for validation) and a random solution generator.
        A generic problem is parameterized on both the solution and data type.
        It is advised to use this class when defining new problems, instead of
        directly implementing the <code>Problem</code> interface, as demonstrated in this example.
    </p>
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Modelling constraints
        </h4>
        The basic TSP problem which is solved here does not have any constraints. To learn about modelling constraints in JAMES, see
        examples <a href="/examples/knapsack/">2A</a> and <a href="/examples/knapsack2/">2B</a>.
    </div>
    
    <h4 class="page-header" id="data">
        Providing the data
    </h4>
    <p>
        Data is stored in a separate class and accessed by the other problem components
        to evaluate, validate and generate random solutions. For our basic TSP problem, the data consists of a (symmetric) distance matrix
        containing the travel distance between each pair of cities. The numbers assigned to the cities correspond to the row and column indices
        in this matrix.
        The data type of a problem is not confined in any way, i.e. it is not required to implement a certain interface or extend an (abstract)
        class. Here, we create a <code>TSPData</code> class that wraps the travel distance matrix. Methods are provided to retrieve the distance
        between two cities and the number of cities.
    </p>
<pre class="prettyprint">
public class TSPData {

    // travel distance matrix
    private double[][] dist;

    public TSPData(double[][] dist) {
        this.dist = dist;
    }
    
    // get travel distance between two cities
    public double getDistance(int from, int to){
        return dist[from][to];
    }
    
    // retrieve number of cities
    public int getNumCities(){
        return dist.length;
    }
    
}
</pre>
    
    <h4 class="page-header" id="objective">
        Specifying the objective
    </h4>
    <p>
        The objective is used to evaluate solutions generated during optimization. It also informs the search whether the computed values are to be
        maximized or minimized. To provide the objective, implement the <code>Objective</code> interface, which is parameterized on the solution and
        data type of the problem. Here, a solution is evaluated by computing the total travel distance resulting from visiting the cities in the order
        specified in the solution. The computed value is wrapped in a <code>SimpleEvaluation</code>. Since the travel distance is to be minimized, the
        method <code>isMinimizing()</code> returns <code>true</code>.
    </p>
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Evaluation type
        </h4>
        For many problems, it is sufficient to wrap the computed value in a <code>SimpleEvaluation</code> as shown in this example.
        To understand when and why it may be necessary to define a custom evaluation type, see <a href="/examples/coresubset3/">example 1C</a>.
    </div>
<pre class="prettyprint">
public class TSPObjective implements Objective&lt;TSPSolution, TSPData&gt;{

    public Evaluation evaluate(TSPSolution solution, TSPData data) {
        // compute sum of travel distances
        List&lt;Integer&gt; cities = solution.getCities();
        int n = cities.size();
        double totalDistance = 0.0;
        for(int i=0; i&lt;n; i++){
            int fromCity = cities.get(i);
            int toCity = cities.get((i+1)%n);
            totalDistance += data.getDistance(fromCity, toCity);
        }
        // wrap in simple evaluation
        return SimpleEvaluation.WITH_VALUE(totalDistance);
    }
    
    public boolean isMinimizing() {
        return true;
    }

}
</pre>
    
    <h4 class="page-header" id="random-solution-generation">
        Random solution generation
    </h4>
    <p>
         By default, all local searches in JAMES start from a random solution.
         It is therefore required to specify how such random solutions are to be obtained, by implementing the
         <code>RandomSolutionGenerator</code> interface. Again, this interface is parameterized on the solution and data type of the problem.
         It contains a single method <code>create(rnd, data)</code> to create a random solution, using the given source of randomness and
         the problem data. The implementation can be compactly defined as a Java 8 lambda expression, as shown below. To create a
         random solution for our TSP problem, a list with all city numbers [0, N-1] is constructed, shuffled and wrapped in a
         <code>TSPSolution</code> object.
    </p>
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Info
        </h4>
        For some problems, it may not be possible to generate random solutions. A custom initial solution should then be provided when
        applying a local search. See <a href="/examples/clique/">example 3</a>.
    </div>
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Info
        </h4>
        The method <code>create(rnd, data)</code> takes a random generator as its first argument, which should
        be used as the source of randomness. Each search has a dedicated random generator, which is passed to the
        problem when requesting a random solution. If desired, a search's random generator can be customized with
        <code>search.setRandom(rnd)</code>.
    </div>
<pre class="prettyprint">
RandomSolutionGenerator&lt;TSPSolution, TSPData&gt; rsg = (r,d) -> {
    // create random permutation of cities
    List&lt;Integer&gt; cities = new ArrayList&lt;&gt;();
    int n = d.getNumCities();
    for(int i=0; i&lt;n; i++){
        cities.add(i);
    }
    Collections.shuffle(cities, r);
    // create and return TSP solution
    return new TSPSolution(cities);
};
</pre>
    
    <h4 class="page-header" id="combining-problem-components">
        Combining problem components
    </h4>
    <p>
        We can now combine all components in a <code>GenericProblem</code>.
    </p>
<pre class="prettyprint">
// define distance matrix (e.g. read from file)
double[][] dist = ...
    
// create data
TSPData data = new TSPData(dist);
// create objective
TSPObjective obj = new TSPObjective();
// create random solution generator
RandomSolutionGenerator&lt;TSPSolution, TSPData&gt; rsg = ... // see before

// wrap in generic problem
Problem&lt;TSPSolution&gt; problem = new GenericProblem&lt;&gt;(data, obj, rsg); 
</pre>

    <h4 class="page-header" id="neigh">
        Providing a neighbourhood and corresponding move
    </h4>
    <p>
        To be able to apply the available neighbourhood searches we have to provide at least one neighbourhood for the new
        <code>TSPSolution</code> type. Here we create a neighbourhood that reverses a subsequence of cities in a given solution,
        by performing a series of swaps. This is often referred to as a 2-opt move in the context of (symmetric) TSP. All distances
        except the two at the border of the reversed subsequence are retained. The latter two are replaced by two other distances.
    </p>
    <p>
        First, provide the corresponding move by implementing the <code>Move</code> interface with solution type <code>TSPSolution</code>.
        This interface has two methods: one to apply the move and one to undo it after it has been applied to a solution. This specific
        move can be undone by again reversing the subsequence with the exact same code as for applying the move.
    </p>
<pre class="prettyprint">
public class TSP2OptMove implements Move&lt;TSPSolution&gt; {

    // city positions i,j between which the path is reversed as follows:
    // ... - (a) - (c_1) - (c_2)   - ... - (c_n-1) - (c_n) - (b) - ...
    //               i                                 j
    //  =>
    // ... - (a) - (c_n) - (c_n-1) - ... - (c_2)   - (c_1) - (b) - ...
    //               i                                 j
    private final int i, j;

    public TSP2OptMove(int i, int j) {
        // check
        if(i == j){
            throw new IllegalArgumentException("Error: i and j should be distinct positions.");
        }
        // store
        this.i = i;
        this.j = j;
    }

    public int getI(){
        return i;
    }

    public int getJ(){
        return j;
    }

    @Override
    public void apply(TSPSolution solution) {
        // reverse subsequence of cities
        int start = i;
        int stop = j;
        int n = solution.getCities().size();
        int reversedLength;
        if(i &lt; j){
            reversedLength = j-i+1;
        } else {
            reversedLength = n - (i-j-1);
        }
        int numSwaps = reversedLength/2;
        for(int k=0; k&lt;numSwaps; k++){
            solution.swapCities(start, stop);
            start = (start+1) % n;
            stop = (stop-1+n) % n;
        }
    }

    @Override
    public void undo(TSPSolution solution) {
        // undo by reversing again
        apply(solution);
    }

}
</pre>
    <p>
        Then, create the neighbourhood itself by implementing the <code>Neighbourhood</code> interface, again with solution type <code>TSPSolution</code>.
        A neighbourhood has two methods: one to create a random move and one to obtain a list of all possible moves. Here, both methods create moves
        of type <code>TSP2OptMove</code>.
    </p>
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Info
        </h4>
        The method <code>getRandomMove(solution, rnd)</code> takes a random generator as its second argument, which should
        be used as the source of randomness. Each search has a dedicated random generator, which is passed to the neighbourhood
        when requesting a random move. If desired, a search's random generator can be customized with
        <code>search.setRandom(rnd)</code>.
    </div>
<pre class="prettyprint">
public class TSP2OptNeighbourhood implements Neighbourhood&lt;TSPSolution&gt;{

    public TSP2OptMove getRandomMove(TSPSolution solution, Random rnd) {
        // pick two distinct random positions i,j in the round trip
        int n = solution.getCities().size();
        int i = rnd.nextInt(n);
        int j = rnd.nextInt(n-1);
        if(j >= i){
            j++;
        }
        // return 2-opt TSP move that reverses path from position i to j
        return new TSP2OptMove(i, j);
    }

    public List&lt;TSP2OptMove&gt; getAllMoves(TSPSolution solution) {
        // generate a 2-opt TSP move for every pair of positions i,j
        int n = solution.getCities().size();
        List&lt;TSP2OptMove&gt; moves = new ArrayList&lt;&gt;();
        for(int i=0; i&lt;n; i++){
            for(int j=0; j&lt;n; j++){
                if(i != j){
                    moves.add(new TSP2OptMove(i, j));
                }
            }
        }
        return moves;
    }

}
</pre>

    <h4 class="page-header">
        Efficient delta evaluation
    </h4>
    <p>
        It is strongly advised (although optional) to also specify an efficient delta evaluation
        as part of the objective, exploiting the knowledge that a new solution is obtained
        by reversing a subsequence in the previous solution. This can be done by overriding the method
        <code>evaluate(move, curSolution, curEvaluation, data)</code> in the objective. Without
        this custom delta evaluation, moves are evaluated by applying them to the current solution,
        followed by a full evaluation, and finally undoing the applied move. The delta evaluation
        provided here is of course much more efficient. This will cause the applied neighbourhood
        searches to run significantly faster.
    </p>
<pre class="prettyprint">
public class TSPObjective implements Objective&lt;TSPSolution, TSPData&gt;{

    // see before ...

    @Override
    public Evaluation evaluate(Move move, TSPSolution curSolution, Evaluation curEvaluation, TSPData data){
        
        // check move type
        if(!(move instanceof TSP2OptMove)){
            throw new IncompatibleDeltaEvaluationException("Delta evaluation in TSP objective expects move of type TSP2OptMove.");
        }
        // cast move
        TSP2OptMove move2opt = (TSP2OptMove) move;
        // get bounds of reversed subsequence
        int i = move2opt.getI();
        int j = move2opt.getJ();
        // get number of cities
        int n = data.getNumCities();
        
        if((j+1)%n == i){
            // special case: entire round trip reversed
            return curEvaluation;
        } else {
            // get current total travel distance
            double totalDistance = curEvaluation.getValue();
            // get current order of cities
            List&lt;Integer&gt; cities = curSolution.getCities();

            // get crucial cities (at boundary of reversed subsequence)
            int beforeReversed = cities.get((i-1+n)%n);
            int firstReversed = cities.get(i);
            int lastReversed = cities.get(j);
            int afterReversed = cities.get((j+1)%n);

            // account for dropped distances
            totalDistance -= data.getDistance(beforeReversed, firstReversed);
            totalDistance -= data.getDistance(lastReversed, afterReversed);

            // account for new distances
            totalDistance += data.getDistance(beforeReversed, lastReversed);
            totalDistance += data.getDistance(firstReversed, afterReversed);

            // return updated travel distance
            return SimpleEvaluation.WITH_VALUE(totalDistance);
        }
        
    }

    // see before ...

}
</pre>

    <h4 class="page-header" id="optimization">
        Optimizing the round trip
    </h4>
    <p>
        Applying an optimization algorithm is now done in exactly the same way as for subset selection problems
        (see <a href="/examples/#subset-selection">subset selection examples</a>).
        After the problem has been created, it is passed to a search that attempts to find a round trip with minimum
        total travel distance using the provided 2-opt neighbourhood. Example code is shown below for the basic
        <a href="/docs/#random-descent">random descent</a> as well as the advanced
        <a href="/docs/#parallel-tempering">parallel tempering</a> algorithms.
    </p>
    <p>
        A <a href="/docs/#random-descent">random descent</a> search is simple, fast and does not have any additional parameters.
    </p>
<pre class="prettyprint">
// create random descent search with TSP neighbourhood
LocalSearch&lt;TSPSolution&gt; randomDescent = new RandomDescent&lt;&gt;(problem, new TSP2OptNeighbourhood());
// set maximum runtime
long timeLimit = ...
randomDescent.addStopCriterion(new MaxRuntime(timeLimit, TimeUnit.SECONDS));
// attach listener (see example 1A)
randomDescent.addSearchListener(new ProgressSearchListener());

// start search
randomDescent.start();

// print results
if(randomDescent.getBestSolution() != null){
    System.out.println("Best round trip: " + randomDescent.getBestSolution().getCities());
    System.out.println("Best round trip travel distance: " + randomDescent.getBestSolutionEvaluation());
} else {
    System.out.println("No valid solution found...");
}

// dispose
randomDescent.dispose();
</pre>
    <p>
        To be able to escape from local optima, more advanced techniques such as
        <a href="/docs/#parallel-tempering">parallel tempering</a> might be needed.
        When using the parallel tempering algorithm, it is important to set an appropriate temperature range
        (also see examples <a href="/examples/coresubset3/#parallel-tempering">1C</a> and <a href="/examples/knapsack/#parallel-tempering">2A</a>)
        taking into account the scale of the evaluations. In particular, the probability to accept an inferior move is determined based on the ratio
        of the difference in evaluation (delta) and the temperature of the system.
        Here, the scale of the expected deltas depends on that of the distances between cities.
        Therefore, temperatures are scaled according to the average travel distance between each city and the closest other city.
        Alternatively, we could have rescaled the distances.
    </p>
    <p>
        The (unscaled) temperature range was refined to [10<sup>-8</sup>, 0.6]
        using the analysis workflow, based on experiments with a number of
        <a href="http://www.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/" target="_blank">TSPLIB instances</a>.
        A detailed demonstration of how this can be done, for a different problem (core subset selection),
        is provided in example <a href="/examples/parametersweep">5A</a>.
    </p>
<pre class="prettyprint">
// set temperature range, scaled according to average
// distance between cities and their nearest neighbours
double scale = computeAvgNearestNeighbourDistance(data);
double minTemp = scale * 1e-8;
double maxTemp = scale * 0.6;
// create parallel tempering search with TSP neighbourhood
int numReplicas = 10;
ParallelTempering&lt;TSPSolution&gt; parallelTempering = new ParallelTempering&lt;&gt;(
                                                        problem,
                                                        new TSP2OptNeighbourhood(),
                                                        numReplicas, minTemp, maxTemp
                                                   );
</pre>
    <p>
        The average travel distance between cities and their closest neighbour is easily computed.
    </p>
<pre class="prettyprint">
double computeAvgNearestNeighbourDistance(TSPData data){
    int n = data.getNumCities();
    double sum = 0.0;
    for(int i=0; i&lt;n; i++){
        double min = Double.MAX_VALUE;
        for(int j=0; j&lt;n; j++) {
            double dist = data.getDistance(i, j);
            if(dist > 0.0 &amp;&amp; dist &lt; min){
                min = dist;
            }
        }
        sum += min;
    }
    return sum/n;
}
</pre>
    <p>
        Running the parallel tempering search is now done in exactly the same way as for the random descent search. However,
        it is able to find much better solutions, i.e. round trips with a much lower total travel distance.
    </p>

    <h4 class="page-header">
        Full source code
    </h4>
    <p>
        The complete source code of this example is available on
        <a href="https://github.com/hdbeukel/james-examples/tree/v{{site.examples-latest-stable}}/src/main/java/org/jamesframework/examples/tsp">GitHub</a>,
        including some additional code to read the input from a text file.
        You can also download a <a href="/getstarted/#releases-examples">ZIP file</a> that contains the Java sources of all examples, a compiled
        JAR (including all dependencies) as well as some input files for in case you want to run any of the examples. To run this example, execute
    </p>
<pre class="prettyprint">
$ java -cp james-examples.jar org.jamesframework.examples.tsp.TSP &lt;inputfile&gt; &lt;runtime&gt;
</pre>
    </p>
        from the command line.
        The first line of the input file contains a single integer value (possibly surrounded by whitespace)
        that indicates the number of cities N. The remainder of the file contains the entries of the
        lower triangular part of an N &times; N symmetric distance matrix (row-wise without diagonal entries),
        separated by whitespace and/or newlines.
        The runtime is given in seconds.
    </p>
    <p>
        <ul class="list-unstyled">
            <li>
                <a href="/files/examples/TSP1.txt"><i class="fa fa-file-text-o"></i> Example input file (17 cities)</a>
            </li>
            <li>
                <a href="/files/examples/TSP2.txt"><i class="fa fa-file-text-o"></i> Example input file (48 cities)</a>
            </li>
            <li>
                <a href="/files/examples/TSP3.txt"><i class="fa fa-file-text-o"></i> Example input file (120 cities)</a>
            </li>
            <li>
                <a href="/files/examples/TSP4.txt"><i class="fa fa-file-text-o"></i> Example input file (561 cities)</a>
            </li>
        </ul>
    </p>
    <p>
        The example input files correspond to instances gr17, gr48, gr120 and pa561, respectively, from the
        <a href="http://www.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/" target="_blank">TSPLIB benchmark set</a>.
    </p>

</div>
