---
layout: default
---

<div id="examples-coresubset">
    <ol class="breadcrumb">
        <li><a href="/index.html">Home</a></li>
        <li><a href="/examples">Examples</a></li>
        <li class="active">Core subset selection</li>
    </ol>
    
    <h2 class="page-header">
        Example 1: Core subset selection
    </h2>
    
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Info
        </h4>
        In this example the random descent metaheuristic is applied to sample a good core subset. Don't know what random descent is?
        Read <a href="/docs/#random-descent">this</a>.
    </div>
    <p>
        This example demonstrates the implementation of a simple core subset selection problem in James. Given a distance matrix, the goal
        is to select a subset of items so that the average distance between all pairs of selected items is maximized. 
        Every item also has a name. Therefore, the input consists of the combination of an N &times; N distance matrix and an array of N
        item names (in corresponding order).
    </p>
    
    <h4 class="page-header">
        Providing the data
    </h4>
    <p>
        First create a data class <code>CoreSubsetData</code> by implementing the <code>IntegerIdentifiedData</code> interface.
        The data contains the distance matrix and item names, and every item is assigned
        a unique integer ID. Here the IDs correspond to the respective indices in the distance matrix and name array.
        The <code>IntegerIdentifiedData</code> interface has a single required method <code>getIDs()</code>
        which returns the set of all IDs that have been assigned to the items. The framework needs to know these
        IDs so that any subset selection problem can be translated into the generic problem of selecting a subset of IDs.
    </p>
<pre class="prettyprint">
public class CoreSubsetData implements IntegerIdentifiedData {

    // item names
    private String[] names;
    // distance matrix
    private double[][] dist;
    // IDs
    private Set<Integer> ids;

    public CoreSubsetData(String[] names, double[][] dist){
        // store data
        this.names = names;
        this.dist = dist;
        // infer IDs: 0..N-1 in case of N items
        // (indices in distance matrix and name array)
        ids = new HashSet&lt;&gt;();
        for(int id=0; id&lt;names.length; id++){
            ids.add(id);
        }
    }

    public Set&lt;Integer&gt; getIDs() {
        return ids;
    }
    
}
</pre>
    <p>
        Now add two custom methods to access the underlying data based on IDs of selected items.
        The method <code>getName(int id)</code> returns the name of an item with a given ID and <code>getDistance(int id1, int id2)</code>
        yields the distance between two items.
    </p>
<pre class="prettyprint">
public String getName(int id){
    return names[id];
}

public double getDistance(int id1, int id2){
    return dist[id1][id2];
}
</pre>
    
    <h4 class="page-header" id="objective">
        Defining the objective
    </h4>
    <p>
        Now create a class <code>CoreSubsetObjective</code> that implements the <code>Objective</code> interface. This interface has two
        type parameters: the solution and data type. Set the solution type to <code>SubsetSolution</code> (as for all
        subset selection problems) and the data type to <code>CoreSubsetData</code> (specifically for this example).
        The <code>Objective</code> interface requires to implement two methods:
        <ol>
            <li>
                <code>Evaluation evaluate(SubsetSolution, CoreSubsetData)</code>: evaluates a subset solution given our core subset data.
                The solution indicates the IDs of the selected items based on which the necessary data can be retrieved. In this example,
                the average distance between all selected items is computed. The value is fixed to 0.0 if less than 2 items are selected
                (no distances).
            </li>
            <li>
                <code>boolean isMinimizing()</code>: indicates whether evaluations are to be minimized or maximized, i.e. whether lower
                values or higher values are better, respectively. In this example, <code>false</code> is returned as the average distance
                is to be maximized.
            </li>
        </ol>
        The <code>evaluate(...)</code> method returns an object of type <code>Evaluation</code> (interface) that can be converted into
        a double value by calling <code>getValue()</code>. A predefined implementation of a <code>SimpleEvaluation</code> is provided that
        merely wraps a double value. For this example we can just compute the average distance as a double value and wrap it in
        such simple evaluation object when returning. <a href="/examples/coresubset2">Example 1B</a> and
        <a href="/examples/coresubset3">example 1C</a> further explain why <code>evaluate(...)</code> 
        returns an evaluation object and not just a plain double value, and how this can be
        used to implement efficient delta evaluations. For now, we will keep things simple.
    </p>
<pre class="prettyprint">
public class CoreSubsetObjective implements Objective&lt;SubsetSolution, CoreSubsetData&gt;{
    
    public Evaluation evaluate(SubsetSolution solution, CoreSubsetData data) {
        double value = 0.0;
        if(solution.getNumSelectedIDs() &gt;= 2){
            // at least two items selected: compute average distance
            int numDist = 0;
            double sumDist = 0.0;
            Integer[] selected = new Integer[solution.getNumSelectedIDs()];
            solution.getSelectedIDs().toArray(selected);
            for(int i=0; i&lt;selected.length; i++){
                for(int j=i+1; j&lt;selected.length; j++){
                    sumDist += data.getDistance(selected[i], selected[j]);
                    numDist++;
                }
            }
            value = sumDist/numDist;
        }
        return new SimpleEvaluation(value);
    }

    public boolean isMinimizing() {
        return false;
    }

}
</pre>
    
    <h4 class="page-header">
        Selecting a core subset
    </h4>
    <p>
        We are now ready to apply an optimization algorithm to sample a good core subset. Here we will use the
        <a href="/docs/#random-descent">random descent</a> algorithm, starting from a random initial solution (default)
        with the predefined <code>SingleSwapNeighbourhood</code>.
        This neighbourhood generates moves that swap a single selected and unselected ID.
        The data and objective are combined in a
        <code>SubsetProblem</code> with data type <code>CoreSubsetData</code>.
        When creating the problem, the desired subset size is also specified.
        The problem is then passed to the search to find a good solution.
        Note that searches are parameterized on the solution type
        of the problem that is being solved, which should be set to <code>SubsetSolution</code> for this example.
    </p>
    <p>
        A maximum runtime is set before starting the search.
        Alternatively, a diffferent stop criterion could be used such as a maximum number of steps
        or a maximum time without finding any improvement. Calling <code>search.start()</code> blocks
        until the search has terminated, after which the best found solution and its evaluation are
        printed to the console. Here, the data is used again to map selected IDs to item names.
        Finally, the search is disposed so that all resources are released.
    </p>
<pre class="prettyprint">
// set name array and distance matrix (e.g. read from a file)
String[] names = ...
double[][] dist = ...
// create data object
CoreSubsetData data = new CoreSubsetData(names, dist);
// create objective
CoreSubsetObjective obj = new CoreSubsetObjective();

// combine data and objective in a subset problem, specify desired subset size
int subsetSize = ...
SubsetProblem&lt;CoreSubsetData&gt; problem = new SubsetProblem&lt;&gt;(obj, data, subsetSize);

// create random descent search with single swap neighbourhood
RandomDescent&lt;SubsetSolution&gt; search = new RandomDescent&lt;&gt;(problem, new SingleSwapNeighbourhood());
// set maximum runtime (in seconds)
long timeLimit = ...
search.addStopCriterion(new MaxRuntime(timeLimit, TimeUnit.SECONDS));

// start search
search.start();

// print best solution and evaluation
System.out.println("Best solution (IDs): " + search.getBestSolution().getSelectedIDs());
System.out.println("Best solution (names): " + search.getBestSolution().getSelectedIDs()
                                                                       .stream()
                                                                       .map(data::getName)
                                                                       .collect(Collectors.toSet()));
System.out.println("Best solution evaluation: " + search.getBestSolutionEvaluation());

// dispose search
search.dispose();
</pre>

    <h4 id="search-listener" class="page-header">
        Optional: tracking the search progress
    </h4>
    <p>
        It is possible to attach one or more search listeners to a search engine. These are informed by the algorithm when certain
        events occur. For example, an event is fired when the search has started, stopped or found a new best solution. We now
        create a <code>ProgressSearchListener</code> that prints messages to the console to stay informed about the progress
        of a search.
    </p>
<pre class="prettyprint">
public class ProgressSearchListener implements SearchListener&lt;Solution&gt; {

    public void searchStarted(Search search) {
        System.out.println(" &gt;&gt;&gt; Search started");
    }

    public void searchStopped(Search search) {
        System.out.println(" >>> Search stopped (" + search.getRuntime()/1000 + " sec, " + search.getSteps() + "  steps)");
    }

    public void newBestSolution(Search search,
                                Solution newBestSolution,
                                Evaluation newBestSolutionEvaluation,
                                Validation newBestSolutionValidation) {
        System.out.println(" &gt;&gt;&gt; New best solution: " + newBestSolutionEvaluation);
    }
    
}
</pre>
    <p>
        Search listeners are parameterized on the solution type of the searches to which they can listen. However, the solution
        type of a listener is allowed to be more general than the solution type of the search (i.e. a super class or interface).
        As our progress listener does not perform any solution type specific actions, its solution type is set to
        the top-level class <code>Solution</code>. It can thus be used to track the progress of any search with any
        solution type as these are all required to be subclasses of <code>Solution</code>.
    </p>
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-lightbulb-o"></i>
            Good to know
        </h4>
        All methods in the <code>SearchListener</code> interface have a default empty implementation.
        Listeners can therefore simply ignore any callbacks for which no action is to be taken.
    </div>
    <p>
        To track the progress of the applied random descent algorithm, simply add the listener before starting the search.
    </p>
<pre class="prettyprint">
search.addSearchListener(new ProgressSearchListener());
</pre>

    <h4 class="page-header">
        Full source code
    </h4>
    <p>
        The complete source code of this example is available on
        <a href="https://github.com/hdbeukel/james/tree/v{{site.examples-latest-stable}}/james/james-examples/src/main/java/org/jamesframework/examples/coresubset">GitHub</a>,
        including some additional code to read the input from a CSV file.
        You can also download a <a href="/getstarted/#releases-examples">ZIP file</a> that contains the Java sources of all examples, a compiled
        JAR (including all dependencies) as well as some input files for in case you want to run any of the examples. To run this example, execute
    </p>
<pre class="prettyprint">
$ java -cp james-examples.jar org.jamesframework.examples.coresubset.CoreSubset &lt;inputfile&gt; &lt;subsetsize&gt; &lt;runtime&gt;
</pre>
    </p>
        from the command line. The input file should be a CSV file in which the first row contains N item names and the subsequent N rows
        specify an N &times; N distance matrix. The runtime is given in seconds.
    </p>
    <p>
        <a href="/files/examples/coresubset.csv"><i class="fa fa-file-text-o"></i> Example input file (100 items)</a>
    </p>
    
</div>


















