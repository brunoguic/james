---
layout: default
---

<div>
    <ol class="breadcrumb">
        <li><a href="/index.html">Home</a></li>
        <li><a href="/examples">Examples</a></li>
        <li class="active">Core subset selection (3)</li>
    </ol>

    <h2 class="page-header">
        Example 1C: Core subset selection (3)
    </h2>

    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-info-circle"></i>
            Info
        </h4>
        The random descent and parallel tempering algorithms are applied to sample a good core subset. Don't know what random descent is?
        Read <a href="/docs/#random-descent">this</a>. Never heard about parallel tempering? Read <a href="/docs/#parallel-tempering">this</a>.
    </div>
    <p>
        This example demonstrates the implementation of a core subset selection problem
        (see <a href="/examples/coresubset/">example 1A</a> and <a href="/examples/coresubset2/">example 1B</a>) with a different objective: maximize the
        average distance of each selected item to the <em>closest</em> other selected item (instead of the average distance between <em>all</em> pairs).
        To be able to provide an efficient delta evaluation, the objective generates custom evaluation objects that store additional
        metadata. Both a basic random descent as well as an advanced parallel tempering algorithm are applied to optimize the core.
    </p>

    <h4 class="page-header">
        Defining the objective
    </h4>
    <p>
        To evaluate a subset we iterate over all selected items and find the closest other selected item to compute the average <em>entry-to-nearest-entry</em> distance. This value is to be maximized.
    </p>
<pre class="prettyprint">
public class EntryToNearestEntryObjective implements Objective&lt;SubsetSolution, CoreSubsetData&gt;{

    public Evaluation evaluate(SubsetSolution solution, CoreSubsetData data) {
        double value = 0.0;
        if(solution.getNumSelectedIDs() &gt;= 2){
            // sum distances to closest other selected item
            int numDist = 0;
            double sumDist = 0.0;
            Set&lt;Integer&gt; selected = solution.getSelectedIDs();
            for(int sel : selected){
                // find closest other selected item
                int closestOther = findClosest(sel, selected, data);
                // add distance to sum
                sumDist += data.getDistance(sel, closestOther);
                numDist++;
            }
            // divide by number of distances
            value = sumDist/numDist;
        }
        return SimpleEvaluation.WITH_VALUE(value);
    }

    // finds the item in the given collection that is closest to the given item;
    // null if the collection does not contain any items different from the given item
    private Integer findClosest(int item, Collection&lt;Integer&gt; group, CoreSubsetData data){
        double dist;
        Double minDist = null;
        Integer closestOther = null;
        for(int other : group){
            if(other != item){
                dist = data.getDistance(item, other);
                if(minDist == null || dist &lt; minDist){
                    minDist = dist;
                    closestOther = other;
                }
            }
        }
        return closestOther;
    }

    public boolean isMinimizing() {
        return false;
    }

}
</pre>

    <h4 class="page-header">
        Efficient delta evaluation
    </h4>
    <p>
        We might also want to include an efficient delta evaluation (see <a href="/examples/coresubset2/#delta-eval">example 1B</a>)
        to speed up applied neighbourhood searches.
    </p>
<pre class="prettyprint">
public Evaluation evaluate(Move move, SubsetSolution curSolution, Evaluation curEvaluation, CoreSubsetData data){
    // provide efficient delta evaluation here ...
}
</pre>
    <p>
        However, for this objective, it is not possible to efficiently compute the modified evaluation when only the current solution, its evaluation (value) and the applied move are available.
        The full evaluation from above finds the closest other selected item for each item in the selection, but this information is lost when
        returning the average of the respective distances wrapped in a <code>SimpleEvaluation</code>.
        If we keep track of this metadata, it can be efficiently updated
        when performing a delta evaluation. The new average <em>entry-to-nearest-entry</em> distance is then inferred from the updated metadata.
    </p>
    <p>
        With this approach in mind we create a custom evaluation object that implements the <code>Evaluation</code> interface.
        It keeps track of the closest neighbour of each item in the selection. The only required method <code>getValue()</code>
        returns the average <em>entry-to-nearest-entry</em> distance which is updated whenever the metadata changes.
    </p>
<pre class="prettyprint">
public class EntryToNearestEntryEvaluation implements Evaluation {

    // maps items to closest other items (IDs)
    private Map&lt;Integer, Integer&gt; closestItemMap;
    // maps items to distance to respective closest item
    private Map&lt;Integer, Double&gt; minDistMap;

    // sum of distances from items to respective closest items
    private double minDistSum;

    public EntryToNearestEntryEvaluation() {
        closestItemMap = new HashMap&lt;&gt;();
        minDistMap = new HashMap&lt;&gt;();
        minDistSum = 0.0;
    }

    // deep copy constructor
    public EntryToNearestEntryEvaluation(EntryToNearestEntryEvaluation toCopy){
        closestItemMap = new HashMap&lt;&gt;(toCopy.closestItemMap);
        minDistMap = new HashMap&lt;&gt;(toCopy.minDistMap);
        minDistSum = toCopy.minDistSum;
    }

    // add item
    public void add(int itemID, int closestOtherItemID, double distance){
        // update minimum distance sum
        minDistSum += distance;
        // update metadata
        closestItemMap.put(itemID, closestOtherItemID);
        minDistMap.put(itemID, distance);
    }

    // remove item
    public boolean remove(int itemID){
        if(closestItemMap.containsKey(itemID)){
            // update minimum distance sum
            minDistSum -= minDistMap.get(itemID);
            // update metadata
            closestItemMap.remove(itemID);
            minDistMap.remove(itemID);
            return true;
        }
        return false;
    }

    // update closest item
    public boolean update(int itemID, int closestOtherItemID, double distance){
        if(closestItemMap.containsKey(itemID)){
            // update minimum distance sum
            minDistSum -= minDistMap.get(itemID);
            minDistSum += distance;
            // update metadata
            closestItemMap.put(itemID, closestOtherItemID);
            minDistMap.put(itemID, distance);
            return true;
        }
        return false;
    }

    // get closest item (null of no closest item registered)
    public Integer getClosest(int itemID){
        return closestItemMap.get(itemID);
    }

    // return average distance from each item to closest item; 0.0 if no distances
    public double getValue() {
        int numDistances = minDistMap.size();
        if(numDistances > 0){
            return minDistSum/numDistances;
        } else {
            return 0.0;
        }
    }

}
</pre>
    <p>
        Now we can modify the objective to use this custom evaluation type and provide an efficient delta evaluation. The received
        evaluation of the current solution is cast to an <code>EntryToNearestEntryEvaluation</code> so that we can access
        and update the metadata. This cast can not fail as both <code>evaluate(...)</code> methods (full and delta) return an evaluation of this type.
        If an item's closest neighbour is not removed from the selection it suffices to check whether any of the added items is even closer.
        Of course, this is much more efficient as compared to rescanning the entire new selection to find each item's closest neighbour.
    </p>
<pre class="prettyprint">
public class EntryToNearestEntryObjective implements Objective&lt;SubsetSolution, CoreSubsetData&gt;{

    public Evaluation evaluate(SubsetSolution solution, CoreSubsetData data) {
        // initialize evaluation object
        EntryToNearestEntryEvaluation eval = new EntryToNearestEntryEvaluation();
        // find closest neighbour of each item in the selection
        Set&lt;Integer&gt; selected = solution.getSelectedIDs();
        for(int sel : selected){
            // find closest other selected item
            Integer closestOther = findClosest(sel, selected, data);
            // register closest item in evaluation object (if any)
            if(closestOther != null){
                eval.add(sel, closestOther, data.getDistance(sel, closestOther));
            }
        }
        return eval;
    }

    // finds the item in the given collection that is closest to the given item;
    // null if the collection does not contain any items different from the given item
    private Integer findClosest(int item, Collection&lt;Integer&gt; group, CoreSubsetData data){
        // same as before ...
    }

    public Evaluation evaluate(Move move, SubsetSolution curSolution, Evaluation curEvaluation, CoreSubsetData data){
        // check move type
        if(!(move instanceof SubsetMove)){
            throw new IncompatibleDeltaEvaluationException("Entry to nearest entry objective should be used in "
                                     + "combination with neighbourhoods that generate moves of type SubsetMove.");
        }
        // cast move
        SubsetMove subsetMove = (SubsetMove) move;

        // cast evaluation (cannot fail as both evaluate methods return such evaluation object)
        EntryToNearestEntryEvaluation eval = (EntryToNearestEntryEvaluation) curEvaluation;
        // copy to initialize new evaluation
        EntryToNearestEntryEvaluation newEval = new EntryToNearestEntryEvaluation(eval);

        // get added and deleted IDs from move
        Set&lt;Integer&gt; added = subsetMove.getAddedIDs();
        Set&lt;Integer&gt; deleted = subsetMove.getDeletedIDs();
        // get current selection from solution
        Set&lt;Integer&gt; curSelection = curSolution.getSelectedIDs();
        // infer new selection
        List&lt;Integer&gt; newSelection = new ArrayList&lt;&gt;(curSelection);
        newSelection.addAll(added);
        newSelection.removeAll(deleted);

        // discard contribution of removed items
        for(int item : deleted){
            newEval.remove(item);
        }

        // update closest items in new selection
        for(int item : newSelection){
            Integer curClosest = newEval.getClosest(item);
            if(curClosest == null){
                // case 1: previously unselected or no closest item set (less than two items selected);
                //         search for closest item in new selection
                Integer newClosest = findClosest(item, newSelection, data);
                // register, if any
                if(newClosest != null){
                    newEval.add(item, newClosest, data.getDistance(item, newClosest));
                }
            } else {
                // case 2: current closest item needs to be updated
                if(deleted.contains(curClosest)){
                    // case 2A: current closest item removed, rescan entire new selection
                    Integer newClosest = findClosest(item, newSelection, data);
                    // update, if any
                    if(newClosest != null){
                        newEval.update(item, newClosest, data.getDistance(item, newClosest));
                    } else {
                        // no closest item left (less than two items selected); discard
                        newEval.remove(item);
                    }
                } else {
                    // case 2B: current closest item retained; only check if any newly
                    //          added item is closer
                    Integer closestAddedItem = findClosest(item, added, data);
                    if(closestAddedItem != null
                        &amp;&amp; data.getDistance(item, closestAddedItem) &lt; data.getDistance(item, curClosest)){
                        // update closest item
                        newEval.update(item, closestAddedItem, data.getDistance(item, closestAddedItem));
                    }
                }
            }
        }

        return newEval;
    }

    public boolean isMinimizing() {
        return false;
    }

}
</pre>

    <h4 class="page-header">
        Selecting a core subset
    </h4>
    <p>
        As in <a href="/examples/coresubset/#select-core">example 1A</a> we can easily apply a basic random descent search to select a core,
        using the predefined <code>SingleSwapNeighbourhood</code>. The only difference is the objective function.
    </p>
<pre class="prettyprint">
// set name array and distance matrix (e.g. read from a file)
String[] names = ...
double[][] dist = ...
// create data object
CoreSubsetData data = new CoreSubsetData(names, dist);
// create objective
EntryToNearestEntryObjective obj = new EntryToNearestEntryObjective();

// combine data and objective in a subset problem, specify desired subset size
int subsetSize = ...
SubsetProblem&lt;CoreSubsetData&gt; problem = new SubsetProblem&lt;&gt;(obj, data, subsetSize);

// create random descent search with single swap neighbourhood
RandomDescent&lt;SubsetSolution&gt; search = new RandomDescent&lt;&gt;(problem, new SingleSwapNeighbourhood());
// set maximum runtime (in seconds)
long timeLimit = ...
search.addStopCriterion(new MaxRuntime(timeLimit, TimeUnit.SECONDS));
// attach listener (see example 1A)
search.addSearchListener(new ProgressSearchListener());

// start search
search.start();

// print best solution and evaluation
System.out.println("Best solution (IDs): " + search.getBestSolution().getSelectedIDs());
System.out.println("Best solution (names): " + search.getBestSolution().getSelectedIDs()
                                                                       .stream()
                                                                       .map(data::getName)
                                                                       .collect(Collectors.toSet()));
System.out.println("Best solution evaluation: " + search.getBestSolutionEvaluation());

// dispose search
search.dispose();
</pre>
    <p>
        However, you may notice a slight variation in solution quality across repeated runs of this algorithm. This means that
        the search gets stuck in local optima of varying quality, i.e. this objective seems harder to optimize than
        the average pairwise distance objective from <a href="/examples/coresubset/#objective">example 1A</a>. More advanced
        algorithms can be applied to escape from such local optima.
    </p>
    <p id="parallel-tempering">
        An example of an advanced method is the <a href="/docs/#parallel-tempering">parallel tempering</a> algorithm,
        which concurrently runs several <a href="/docs/#metropolis-search">Metropolis searches</a>
        with different temperatures. Higher temperatures correspond to higher probabilities to accept inferior moves.
        The  subsearches swap solutions so that the best solutions are pushed to the coolest systems, for convergence,
        and the worst solutions are pushed to the hot systems, which offer a lot of freedom for further modifications.
        The parallel tempering algorithm is somewhat similar to simulated annealing but takes advantage of multi-core CPUs,
        as the subsearches can be executed in parallel. Also, it has a built-in multi-start behaviour.
    </p>
    <p>
        When applying parallel tempering, the number of Metropolis replicas and the minimum and maximum temperature are specified.
        It is important to set appropriate temperatures, taking into account the evaluation range. For example, whether a temperature
        of 0.0001 is considered high or low strongly depends on whether evaluations range from e.g. zero to one or ten thousand up to
        a hundred thousand.
    </p>
    <div class="bs-callout bs-callout-info">
        <h4>
            <i class="fa fa-lightbulb-o"></i>
            Temperature range
        </h4>
        To find an appropriate temperature range to be used for parallel tempering, it might help to experiment with individual Metropolis
        searches with different fixed temperatures.
    </div>
<pre class="prettyprint">
// create parallel tempering search with single swap neighbourhood
double minTemp = 1e-8;
double maxTemp = 1e-4;
int numReplicas = 10;
ParallelTempering&lt;SubsetSolution&gt; search = new ParallelTempering&lt;&gt;(problem,
                                                                   new SingleSwapNeighbourhood(),
                                                                   numReplicas, minTemp, maxTemp);
// same as before ...
</pre>
    <p>
        If you run this example you will notice that applying parallel tempering reduces variability across repeated search runs and, on average,
        yields solutions with a slightly higher value. Nevertheless, it is a more complex and therefore somewhat slower algorithm as
        compared to random descent, which also finds good solutions and has no additional parameters. So both algorithms could be used to solve this
        problem, depending on the precise user requirements.
    </p>

    <h4 class="page-header">
        Full source code
    </h4>
    <p>
        The complete source code of this example is available on
        <a href="https://github.com/hdbeukel/james-examples/tree/v{{site.examples-latest-stable}}/src/main/java/org/jamesframework/examples/coresubset3">GitHub</a>,
        including some additional code to read the input from a CSV file.
        You can also download a <a href="/getstarted/#releases-examples">ZIP file</a> that contains the Java sources of all examples, a compiled
        JAR (including all dependencies) as well as some input files for in case you want to run any of the examples. To run this example, execute
    </p>
<pre class="prettyprint">
$ java -cp james-examples.jar org.jamesframework.examples.coresubset3.CoreSubset3 &lt;inputfile&gt; &lt;subsetsize&gt; &lt;runtime&gt;
</pre>
    </p>
        from the command line. The input file should be a CSV file in which the first row contains N item names and the subsequent N rows
        specify an N &times; N distance matrix. The runtime is given in seconds.
    </p>
    <p>
        <a href="/files/examples/coresubset.csv"><i class="fa fa-file-text-o"></i> Example input file (275 items)</a>
    </p>

</div>
